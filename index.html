<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Shift</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
            color: #fff;
        }
        #gameCanvas {
            border: 2px solid #fff;
            background-color: #333;
        }
        .score {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 20px;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="600"></canvas>
<div class="score" id="score">Score: 0</div>

<script>
    // Game Setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    
    const gravityDirections = ['up', 'down', 'left', 'right'];
    let gravityDirection = 'down';
    let score = 0;
    let gameOver = false;
    
    // Player Variables
    const player = {
        x: 100,
        y: 500,
        width: 50,
        height: 50,
        speed: 5,
        gravity: 0.5,
        velocityX: 0,
        velocityY: 0,
        grounded: false,
        jumpHeight: -15
    };
    
    // Platforms and Obstacles
    let platforms = [{ x: 100, y: 550, width: 200, height: 20 }];
    let obstacles = [];

    // Handle Key Presses
    const keys = {};
    window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
    });
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    // Handle Gravity Shift
    function shiftGravity() {
        gravityDirection = gravityDirections[Math.floor(Math.random() * gravityDirections.length)];
    }

    // Update Game State
    function update() {
        if (gameOver) return;

        // Handle Gravity
        if (gravityDirection === 'down') {
            player.velocityY += player.gravity;
        } else if (gravityDirection === 'up') {
            player.velocityY -= player.gravity;
        } else if (gravityDirection === 'left') {
            player.velocityX -= player.gravity;
        } else if (gravityDirection === 'right') {
            player.velocityX += player.gravity;
        }

        // Player Movement
        if (keys['ArrowLeft']) {
            player.x -= player.speed;
        }
        if (keys['ArrowRight']) {
            player.x += player.speed;
        }
        if (keys[' '] && player.grounded) {
            player.velocityY = player.jumpHeight;
            player.grounded = false;
        }

        // Update Player Position
        player.x += player.velocityX;
        player.y += player.velocityY;

        // Detect Collisions with Walls
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
        if (player.y + player.height > canvas.height) {
            player.y = canvas.height - player.height;
            player.velocityY = 0;
            player.grounded = true;
        }

        // Detect Platform Collision
        for (let platform of platforms) {
            if (player.y + player.height <= platform.y && player.y + player.height + player.velocityY > platform.y && player.x + player.width > platform.x && player.x < platform.x + platform.width) {
                player.velocityY = 0;
                player.grounded = true;
                player.y = platform.y - player.height;
            }
        }

        // Update Score
        score++;
        scoreDisplay.textContent = `Score: ${score}`;

        // Random Gravity Shift Every 3 Seconds
        if (score % 300 === 0) {
            shiftGravity();
        }

        // Game Over Condition
        if (player.y < 0 || player.x < 0 || player.x > canvas.width || player.y > canvas.height) {
            gameOver = true;
            alert('Game Over! Your score is: ' + score);
        }

        // Clear Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Player
        ctx.fillStyle = 'green';
        ctx.fillRect(player.x, player.y, player.width, player.height);

        // Draw Platforms
        ctx.fillStyle = 'brown';
        for (let platform of platforms) {
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }

        // Draw Obstacles
        ctx.fillStyle = 'red';
        for (let obstacle of obstacles) {
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        }

        // Loop the Game
        requestAnimationFrame(update);
    }

    // Initialize Game
    function startGame() {
        platforms = [{ x: 100, y: 550, width: 200, height: 20 }];
        obstacles = [];
        player.x = 100;
        player.y = 500;
        player.velocityX = 0;
        player.velocityY = 0;
        score = 0;
        gameOver = false;
        update();
    }

    // Start the Game
    startGame();
</script>

</body>
</html>
